---
layout: default
---

# 2022全國資訊學科能力競賽 解說（NHSPC2022 Editorial）

---

## A - 礦砂採集

這題是很典型的[連續背包問題](https://en.wikipedia.org/wiki/Continuous_knapsack_problem)。結論非常簡單：只要不斷貪婪地將單位重量價值最大的礦砂放進背包，直到背包已滿或所有礦砂均已被放入，就能最大化總價值。

一個簡單的做法是將所有礦砂依照單位重量價值由大到小排序，依序放入背包直到滿即可。複雜度是 $O(n \log n)$。

### 線性做法

雖然並不是本題的考點，但有一個值得一提的 $O(n)$ 做法存在。以下為了方便說明，假定所有的 $x_i$ 均相異。

1. 隨機選擇一個礦砂 $i$，並將所有的礦砂分為單位價值 $\ge x_i$ 與 $< x_i$ 兩堆。
1. 分歧判斷：
   * 若單位價值 $\ge x_i$ 的礦砂可以塞滿背包，則將 $&lt; x_i$ 的礦砂全刪除，並往大的 $x$ 找答案。
   * 反之則將價值 $\ge x_i$ 的礦砂全刪除，往小的 $x$ 找答案。
1. 搜尋完後得到的值代表「總價值最大時，背包中單位重量價值最小的礦砂」，再用這個價值去反求答案。

演算法與 [quickselect](https://en.wikipedia.org/wiki/Quickselect) 非常相似，期望時間複雜度為 $O(n)$。

---

## B - 村莊與小徑

這題是一道最短路徑的問題，但給定的限制中有幾個點要注意：

1. 給定的圖是 DAG（有向無環圖）。
1. 邊權可能是負的。

條件 1 保證這張圖存在拓樸排序，求解可用 top-down DP，或找出拓樸排序後用 bottom-up DP。

```cpp
// ord = 拓樸排序的點順序
// fr[x] = 連到 x 的所有點

fill(dis, dis+n+1, INF);
dis[1] = 0;
for (int i=1; i<=n; i++) {
  int p = ord[i];
  // 找所有能連到 p 的點 j，更新 p 的最短距離
  for (Edge j: fr[p]) dis[p] = min(dis[p], dis[j.to] + j.weight);
}
```

以上的做法複雜度是 $O(n+m)$，可以在限制內解完所有測資。

### 錯誤／部分解法

值得一提的是這題有幾個預設的錯誤解法：

1. Dijkstra: 不能處理負權的最短路。
1. Bellman–Ford / SPFA: 這類演算法在最糟情況下的複雜度是 $\Theta(nm)$，只能過比較小的測資。（註：SPFA 在圖為隨機生成的情況下跑得非常快，要防止讓 SPFA 過基本上需要構造測資。不過總而言之確實存在 SPFA 無法解過的測資）

---

## C - 樣本解析

把給定的 $X$ 拆成兩個不相交集合 $X_1$ 和 $X_2$，再暴力求出所有樣本和 $X_1$ 及 $X_2$ 的交集狀況就可以了。由於集合的拆法有 $O(2^m)$ 種且枚舉完以後需要花 $O(n)$ 檢查，總時間複雜度為 $O(2^m \times n)$ ($m$ 為 $X$ 的字元種類數)。

要怎麼實作得比較簡潔是這一題的重點，這裡給一些小技巧供參考：

### 用 int 或 std::bitset 表示集合

一個集合可以用一個 int 儲存，其中第 $i$ 個 bit 記錄這個集合有沒有第 $i$ 個元素。接下來就能利用 bitwise and/or 等內建運算來算出題目大部分的所求。如果不喜歡位元運算，C++ 也有提供 std::bitset 以協助實作。

### 枚舉所有的子集合

若用 int 儲存集合，可以用一個 for 迴圈枚舉所有的子集合。

```cpp
for (int i=x; ; i=(i-1)&x) {
  cout << i << '\n';
  if (i==0) break;
}
```

這個迴圈枚舉並輸出 $x$ 的每個子集合 $i$，是常見且有效率的寫法。

### 觀察細節

題目所求的 $P_5$ 是比較難算的部分，但仔細想一想可以發現 $P_5$ 只能是 $0$ 或 $2$。以下簡單說明：

1. 不失一般性，假定 $X$ 和 $S_1$ 有部分交集的關係，取任意 $x \in X\cap S_1$。
1. 如果 $(X_1, X_2)$ 是合法的拆分，交換 $X_1$ 與 $X_2$ 後仍然是一個合法的拆分，故不失一般性假定 $x \in X_1$。
1. 我們發現 $X_1$ 只能是 $X\cap S_1$（此時 $P_5 = 2$），否則無解（此時 $P_5 = 0$）。
   * 如果存在某個 $y\in X_1$ 但 $y\notin X\cap S_1$，則 $y\notin S_1$；但這代表 $X_1$ 和 $S_1$ 有部分交集，矛盾。因此 $X_1\subseteq X\cap S_1$。
   * 如果存在某個 $y\in X\cap S_1$ 但 $y\notin X_1$，則 $y\in X_2$；但這代表 $X_2$ 和 $S_1$ 有部分交集，矛盾。因此 $X\cap S_1\subseteq X_1$。

當然這題測資範圍並不要求觀察出這個結論，即使枚舉所有的子集合仍然能拿到滿分。

---

## D - 水果包裝

---

## E - 共同朋友

---

## F - 歡樂外送點

---

## G - 矩陣相乘

---

## H - 跑跑遊戲場

---

## I - 黑白機
