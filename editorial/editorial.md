---
layout: default
---

# 2022全國資訊學科能力競賽 解說（NHSPC2022 Editorial）

---

## A - 礦砂採集

這題是很典型的[連續背包問題](https://en.wikipedia.org/wiki/Continuous_knapsack_problem)。結論非常簡單：只要不斷貪婪地將單位重量價值最大的礦砂放進背包，直到背包已滿或所有礦砂均已被放入，就能最大化總價值。

一個簡單的做法是將所有礦砂依照單位重量價值由大到小排序，依序放入背包直到滿即可。複雜度是 $O(n \log n)$。

### 線性做法

雖然並不是本題的考點，但有一個值得一提的 $O(n)$ 做法存在。以下為了方便說明，假定所有的 $x_i$ 均相異。

1. 隨機選擇一個礦砂 $i$，並將所有的礦砂分為單位價值 $\ge x_i$ 與 $< x_i$ 兩堆。
1. 分歧判斷：
   * 若單位價值 $\ge x_i$ 的礦砂可以塞滿背包，則將 $&lt; x_i$ 的礦砂全刪除，並往大的 $x$ 找答案。
   * 反之則將價值 $\ge x_i$ 的礦砂全刪除，往小的 $x$ 找答案。
1. 搜尋完後得到的值代表「總價值最大時，背包中單位重量價值最小的礦砂」，再用這個價值去反求答案。

演算法與 [quickselect](https://en.wikipedia.org/wiki/Quickselect) 非常相似，期望時間複雜度為 $O(n)$。

---

## B - 村莊與小徑

這題是一道最短路徑的問題，但給定的限制中有幾個點要注意：

1. 給定的圖是 DAG（有向無環圖）。
1. 邊權可能是負的。

條件 1 保證這張圖存在拓樸排序，求解可用 top-down DP，或找出拓樸排序後用 bottom-up DP。

```cpp
// ord = 拓樸排序的點順序
// fr[x] = 連到 x 的所有點

fill(dis, dis+n+1, INF);
dis[1] = 0;
for (int i=1; i<=n; i++) {
  int p = ord[i];
  // 找所有能連到 p 的點 j，更新 p 的最短距離
  for (Edge j: fr[p]) dis[p] = min(dis[p], dis[j.to] + j.weight);
}
```

以上的做法複雜度是 $O(n+m)$，可以在限制內解完所有測資。

### 錯誤／部分解法

值得一提的是這題有幾個預設的錯誤解法：

1. Dijkstra: 不能處理負權的最短路。
1. Bellman–Ford / SPFA: 這類演算法在最糟情況下的複雜度是 $\Theta(nm)$，只能過比較小的測資。（註：SPFA 在圖為隨機生成的情況下跑得非常快，要防止讓 SPFA 過基本上需要構造測資。不過總而言之確實存在 SPFA 無法解過的測資）

---

## C - 樣本解析

把給定的 $X$ 拆成兩個不相交集合 $X_1$ 和 $X_2$，再暴力求出所有樣本和 $X_1$ 及 $X_2$ 的交集狀況就可以了。由於集合的拆法有 $O(2^m)$ 種且枚舉完以後需要花 $O(n)$ 檢查，總時間複雜度為 $O(2^m \times n)$ ($m$ 為 $X$ 的字元種類數)。

要怎麼實作得比較簡潔是這一題的重點，這裡給一些小技巧供參考：

### 用 int 或 std::bitset 表示集合

一個集合可以用一個 int 儲存，其中第 $i$ 個 bit 記錄這個集合有沒有第 $i$ 個元素。接下來就能利用 bitwise and/or 等內建運算來算出題目大部分的所求。如果不喜歡位元運算，C++ 也有提供 std::bitset 以協助實作。

### 枚舉所有的子集合

若用 int 儲存集合，可以用一個 for 迴圈枚舉所有的子集合。

```cpp
for (int i=x; ; i=(i-1)&x) {
  cout << i << '\n';
  if (i==0) break;
}
```

這個迴圈枚舉並輸出 $x$ 的每個子集合 $i$，是常見且有效率的寫法。

### 觀察細節

題目所求的 $P_5$ 是比較難算的部分，但仔細想一想可以發現 $P_5$ 只能是 $0$ 或 $2$。以下簡單說明：

1. 不失一般性，假定 $X$ 和 $S_1$ 有部分交集的關係，取任意 $x \in X\cap S_1$。
1. 如果 $(X_1, X_2)$ 是合法的拆分，交換 $X_1$ 與 $X_2$ 後仍然是一個合法的拆分，故不失一般性假定 $x \in X_1$。
1. 我們發現 $X_1$ 只能是 $X\cap S_1$（此時 $P_5 = 2$），否則無解（此時 $P_5 = 0$）。
   * 如果存在某個 $y\in X_1$ 但 $y\notin X\cap S_1$，則 $y\notin S_1$；但這代表 $X_1$ 和 $S_1$ 有部分交集，矛盾。因此 $X_1\subseteq X\cap S_1$。
   * 如果存在某個 $y\in X\cap S_1$ 但 $y\notin X_1$，則 $y\in X_2$；但這代表 $X_2$ 和 $S_1$ 有部分交集，矛盾。因此 $X\cap S_1\subseteq X_1$。

當然這題測資範圍並不要求觀察出這個結論，即使枚舉所有的子集合仍然能拿到滿分。

---

## D - 水果包裝

### 觀察與結論

換個方式來思考這一題：假設每次機器在選定最小重量的袋子後，由你決定放入哪顆水果。那麼這題存在一個非常簡單的結論：如果給定的包裝結果是可能的，只要重量越輕的水果越先放，總是能達成該包裝結果。

或許這個結論不難猜，但要好好證明也許會花點時間。假設題目給定的包裝是存在解的，也就是存在一個解的序列：

$$(b_1, w_1), (b_2, w_2), \cdots,(b_n, w_n).$$

這裡用 $(b_i, w_i)$ 代表第 $i$ 步驟的水果放在第 $b_i$ 袋，且放的水果重量為 $w_i$。

我們將焦點放在這個解序列中，由「放入相同袋子的兩步驟」所形成的子區間：

$$(b, w_1), \cdots, (b, w_2).$$

可以發現上述序列若 $w_1 > w_2$，我們其實可以交換這兩個步驟的順序，且合法的解仍然存在：

$$(b, w_2), \cdots, (b, w_1), \cdots$$

儘管交換後 $b$ 一度變輕導致 $(b, w_1)$ 可能會比原本 $(b, w_2)$ 的位置還前面，我們發現在放完 $w_1$ 後，只要這個子區間的水果還沒被放完，$b$ 就不會是最輕的，因此這樣的操作是合法的。（當然，對放水果順序的影響只會出現在注目的子區間內，子區間外的所有順序都無需改動。）

經過複數次上述「交換同袋子水果順序」的操作以後，我們可以將任意一個解的序列交換成對每個袋子而言收到的水果重量皆為從小到大。由於任意解的順序都可以經由以上的交換得到同一個序列，若從小拿到大仍然無法滿足題目給定的包裝，代表無解。

### 實作 O( n(log n + log m) )

實作上我們會需要一個資料結構可以

1. 知道現在最輕且編號最小的袋子 $b$。
1. 將還沒放入 $b$ 且最輕的水果放進 $b$ 裡，並更新 $b$ 的重量。

只要將包裝結果中的每個袋子的水果依重量排序，便可隨時查出該將哪個水果放入袋子中；找出最輕的袋子與更新重量部分，可以用堆積或 std::priority_queue 維護，在 $O(\log m)$ 時間完成每個操作。因此整體的複雜度為 $O(n(\log n+\log m))$。

---

## E - 共同朋友

### O(n³)

首先這題有一個簡單的 naïve $O(n^3)$ 做法:

```cpp
for (int i=1; i<=n; i++) {
  for (int j=i+1; j<=n; j++) {
    if (have_common_friends(i, j))
      answer++;
  }
}
```

計算 `have_common_friends()` 最簡單的方法是寫一個迴圈，需時 $O(n)$。

### O(n³/B)

我們利用 std::bitset f[i] 的第 $j$ 個 bit 記錄 $i$ 和 $j$ 是不是朋友，以優化上述 `have_common_friends()` 的迴圈實作。想求 $i$ 和 $j$ 有沒有共同朋友時，可用 std::bitset 的 and 運算與 method any() (i.e. (f[i] & f[j]).any()) 得出。

由於 std::bitset 的實作方式為 bit array，執行時間會比一般的陣列快數十倍以上。當然自己用陣列來實作 bit array 也是可行的：

```cpp
unsigned bit(int x) {
  return 1u << x;
}

void add_friend(int i, int j) {
  j--;
  f[i][j/32] |= bit(j%32);
}

bool have_common_friends(int i, int j) {
  int len = (n+31) / 32;
  for (int k=0; k<len; k++) {
    if (f[i][k] & f[j][k]) return true;
  }
  return false;
}
```

---

## F - 歡樂外送點

從題敘中的圖 1 可以觀察到所有的商店服務範圍都是一個 $45$ 度的正方形，要怎麼把這題的座標轉 $45$ 度好好用區間資料結構維護就是這一題的重點。

### 座標變換

考慮將平面上的所有點做如下的變換：

$$\begin{pmatrix}x\\y\end{pmatrix} \mapsto \begin{pmatrix}x'\\y'\end{pmatrix} := \begin{pmatrix}x+y\\x-y\end{pmatrix}.$$

可以發現變換前兩點 $(x_1, y_1), (x_2, y_2)$ 的曼哈頓距離 $|x_1-x_2| + |y_1-y_2|$ 等於變換後兩點 $(x_1', y_1'), (x_2', y_2')$ 的[切比雪夫距離](https://en.wikipedia.org/wiki/Chebyshev_distance) $\max\{|x_1'-x_2'|, |y_1'-y_2'|\}$。
在變換後原 $(x, y, r)$ 的範圍就會變成以新座標 $(x+y, x-y)$ 為中心，邊長 $2r$ 且邊平行於 $x, y$ 軸的正方形，也就是說一個映射後的座標 $(a', b')$ 若滿足

$$\begin{cases}x'-r\leq a'\leq x'+r,\\y'-r\leq b'\leq y'+r,\end{cases}$$

則 $(a, b)$ 與 $(x, y)$ 的曼哈頓距離在 $r$ 以內。
注意題目所求為變換前的整數點，而變換後的某個整數點 $(x', y')$ 在變換前也是整數點 (i.e. $(\frac{y'-x'}{2}, \frac{y'+x'}{2}) \in \mathbb{Z}^2$) 的充分必要條件是 $x'\equiv y'\ (\operatorname{mod}2)$，必須小心處理奇偶性問題。

值得一提的是這個變換在程式競賽中頗常見，例如 IOI2017 的 [pair](https://hsin.hr/ioi2007/tasks/solutions.pdf) 也出現一樣的技巧。
上面連結的解析裡面有對這個變換的證明，如果讀者對[旋轉矩陣](https://en.wikipedia.org/wiki/Rotation_matrix)不熟，推薦可以直接把這個變換記起來。

### 掃描線

做完上述變換後，在不考慮題目問的是整數點的情況下，可以把題目簡化成這樣：

> 平面上有一些與 $x,y$ 軸平行的矩形，每塊矩形皆有權重。定義一個點的點負重為所有覆蓋該點的矩形的權重和，請求出點負重的最大值。

這個問題是一個含有區間更新的 2D RMQ 問題，但因為所有矩形為已知，可以離線利用[掃描線](https://en.wikipedia.org/wiki/Sweep_line_algorithm)掃其中一軸，並用線段樹或平衡二元搜尋樹維護掃描線上的最大值，時間複雜度 $O(n \log n)$。

由於原始題目有 $x'\equiv y'\ (\operatorname{mod}2)$ 這個條件，無法直接套用上述的演算法，必須做一些處理。這裡提供兩個參考做法：

1. 用兩棵線段樹維護掃描線上的最大值，一棵只維護奇數座標而另一棵維護偶數座標，查詢時再根據掃描線掃過的範圍決定查哪棵線段樹。
1. 只考慮 $x^{\prime}, y^{\prime}$ 同奇偶的座標並將座標除以 $2$。以偶數座標為例，若原範圍為 $[2, 5]$ 可以將奇數座標去掉 $[2, 4]$ 再除以 2 變成 $[1, 2]$。變換完的座標就可以忽略同奇偶限制直接套用上述的掃描線演算法。

這個將 2D 問題轉成掃描線降維的技巧相當著名，一個應用是計算二維的矩形面積覆蓋問題 ([ref1](https://www.topcoder.com/community/competitive-programming/tutorials/line-sweep-algorithms), [ref2](https://stackoverflow.com/questions/55702005))，有 $40$ 多年的[歷史](https://en.wikipedia.org/wiki/Segment_tree#History)了。
由於這個技巧在網路上可以找到的資源非常多，限於篇幅這裡就不詳細介紹了，對此技巧不熟的讀者也能從學著做這題開始。

---

## G - 矩陣相乘

---

## H - 跑跑遊戲場

---

## I - 黑白機
