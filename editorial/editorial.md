---
layout: default
---

# 2022全國資訊學科能力競賽 解說（NHSPC2022 Editorial）

---

## A - 礦砂採集

這題是很典型的[連續背包問題](https://en.wikipedia.org/wiki/Continuous_knapsack_problem)。結論非常簡單：只要不斷貪婪地將單位重量價值最大的礦砂放進背包，直到背包已滿或所有礦砂均已被放入，就能最大化總價值。

一個簡單的做法是將所有礦砂依照單位重量價值由大到小排序，依序放入背包直到滿即可。複雜度是 $O(n \log n)$。

### 線性做法

雖然並不是本題的考點，但有一個值得一提的 $O(n)$ 做法存在。以下為了方便說明，假定所有的 $x_i$ 均相異。

1. 隨機選擇一個礦砂 $i$，並將所有的礦砂分為單位價值 $\ge x_i$ 與 $< x_i$ 兩堆。
1. 分歧判斷：
   * 若單位價值 $\ge x_i$ 的礦砂可以塞滿背包，則將 $&lt; x_i$ 的礦砂全刪除，並往大的 $x$ 找答案。
   * 反之則將價值 $\ge x_i$ 的礦砂全刪除，往小的 $x$ 找答案。
1. 搜尋完後得到的值代表「總價值最大時，背包中單位重量價值最小的礦砂」，再用這個價值去反求答案。

演算法與 [quickselect](https://en.wikipedia.org/wiki/Quickselect) 非常相似，期望時間複雜度為 $O(n)$。

---

## B - 村莊與小徑

這題是一道最短路徑的問題，但給定的限制中有幾個點要注意：

1. 給定的圖是 DAG（有向無環圖）。
1. 邊權可能是負的。

條件 1 保證這張圖存在拓樸排序，求解可用 top-down DP，或找出拓樸排序後用 bottom-up DP。

```cpp
// ord = 拓樸排序的點順序
// fr[x] = 連到 x 的所有點

fill(dis, dis+n+1, INF);
dis[1] = 0;
for (int i=1; i<=n; i++) {
  int p = ord[i];
  // 找所有能連到 p 的點 j，更新 p 的最短距離
  for (Edge j: fr[p]) dis[p] = min(dis[p], dis[j.to] + j.weight);
}
```

以上的做法複雜度是 $O(n+m)$，可以在限制內解完所有測資。

### 錯誤／部分解法

值得一提的是這題有幾個預設的錯誤解法：

1. Dijkstra: 不能處理負權的最短路。
1. Bellman–Ford / SPFA: 這類演算法在最糟情況下的複雜度是 $\Theta(nm)$，只能過比較小的測資。（註：SPFA 在圖為隨機生成的情況下跑得非常快，要防止讓 SPFA 過基本上需要構造測資。不過總而言之確實存在 SPFA 無法解過的測資）

---

## C - 樣本解析

把給定的 $X$ 拆成兩個不相交集合 $X_1$ 和 $X_2$，再暴力求出所有樣本和 $X_1$ 及 $X_2$ 的交集狀況就可以了。由於集合的拆法有 $O(2^m)$ 種且枚舉完以後需要花 $O(n)$ 檢查，總時間複雜度為 $O(2^m \times n)$ ($m$ 為 $X$ 的字元種類數)。

要怎麼實作得比較簡潔是這一題的重點，這裡給一些小技巧供參考：

### 用 int 或 std::bitset 表示集合

一個集合可以用一個 int 儲存，其中第 $i$ 個 bit 記錄這個集合有沒有第 $i$ 個元素。接下來就能利用 bitwise and/or 等內建運算來算出題目大部分的所求。如果不喜歡位元運算，C++ 也有提供 std::bitset 以協助實作。

### 枚舉所有的子集合

若用 int 儲存集合，可以用一個 for 迴圈枚舉所有的子集合。

```cpp
for (int i=x; ; i=(i-1)&x) {
  cout << i << '\n';
  if (i==0) break;
}
```

這個迴圈枚舉並輸出 $x$ 的每個子集合 $i$，是常見且有效率的寫法。

### 觀察細節

題目所求的 $P_5$ 是比較難算的部分，但仔細想一想可以發現 $P_5$ 只能是 $0$ 或 $2$。以下簡單說明：

1. 不失一般性，假定 $X$ 和 $S_1$ 有部分交集的關係，取任意 $x \in X\cap S_1$。
1. 如果 $(X_1, X_2)$ 是合法的拆分，交換 $X_1$ 與 $X_2$ 後仍然是一個合法的拆分，故不失一般性假定 $x \in X_1$。
1. 我們發現 $X_1$ 只能是 $X\cap S_1$（此時 $P_5 = 2$），否則無解（此時 $P_5 = 0$）。
   * 如果存在某個 $y\in X_1$ 但 $y\notin X\cap S_1$，則 $y\notin S_1$；但這代表 $X_1$ 和 $S_1$ 有部分交集，矛盾。因此 $X_1\subseteq X\cap S_1$。
   * 如果存在某個 $y\in X\cap S_1$ 但 $y\notin X_1$，則 $y\in X_2$；但這代表 $X_2$ 和 $S_1$ 有部分交集，矛盾。因此 $X\cap S_1\subseteq X_1$。

當然這題測資範圍並不要求觀察出這個結論，即使枚舉所有的子集合仍然能拿到滿分。

---

## D - 水果包裝

### 觀察與結論

換個方式來思考這一題：假設每次機器在選定最小重量的袋子後，由你決定放入哪顆水果。那麼這題存在一個非常簡單的結論：如果給定的包裝結果是可能的，只要重量越輕的水果越先放，總是能達成該包裝結果。

或許這個結論不難猜，但要好好證明也許會花點時間。假設題目給定的包裝是存在解的，也就是存在一個解的序列：

\[(b_1, w_1), (b_2, w_2), \cdots,(b_n, w_n).\]

這裡用 $(b_i, w_i)$ 代表第 $i$ 步驟的水果放在第 $b_i$ 袋，且放的水果重量為 $w_i$。

我們將焦點放在這個解序列中，由「放入相同袋子的兩步驟」所形成的子區間：

\[(b, w_1), \cdots, (b, w_2).\]

可以發現上述序列若 $w_1 > w_2$，我們其實可以交換這兩個步驟的順序，且合法的解仍然存在：

\[(b, w_2), \cdots, (b, w_1), \cdots\]

儘管交換後 $b$ 一度變輕導致 $(b, w_1)$ 可能會比原本 $(b, w_2)$ 的位置還前面，我們發現在放完 $w_1$ 後，只要這個子區間的水果還沒被放完，$b$ 就不會是最輕的，因此這樣的操作是合法的。（當然，對放水果順序的影響只會出現在注目的子區間內，子區間外的所有順序都無需改動。）

經過複數次上述「交換同袋子水果順序」的操作以後，我們可以將任意一個解的序列交換成對每個袋子而言收到的水果重量皆為從小到大。由於任意解的順序都可以經由以上的交換得到同一個序列，若從小拿到大仍然無法滿足題目給定的包裝，代表無解。

### 實作 O( n(log n + log m) )

實作上我們會需要一個資料結構可以

1. 知道現在最輕且編號最小的袋子 $b$。
1. 將還沒放入 $b$ 且最輕的水果放進 $b$ 裡，並更新 $b$ 的重量。

只要將包裝結果中的每個袋子的水果依重量排序，便可隨時查出該將哪個水果放入袋子中；找出最輕的袋子與更新重量部分，可以用堆積或 std::priority_queue 維護，在 $O(\log m)$ 時間完成每個操作。因此整體的複雜度為 $O(n(\log n+\log m))$。

---

## E - 共同朋友

### O(n³)

首先這題有一個簡單的 naïve $O(n^3)$ 做法:

```cpp
for (int i=1; i<=n; i++) {
  for (int j=i+1; j<=n; j++) {
    if (have_common_friends(i, j))
      answer++;
  }
}
```

計算 `have_common_friends()` 最簡單的方法是寫一個迴圈，需時 $O(n)$。

### O(n³/B)

我們利用 std::bitset f[i] 的第 $j$ 個 bit 記錄 $i$ 和 $j$ 是不是朋友，以優化上述 `have_common_friends()` 的迴圈實作。想求 $i$ 和 $j$ 有沒有共同朋友時，可用 std::bitset 的 and 運算與 method any() (i.e. (f[i] & f[j]).any()) 得出。

由於 std::bitset 的實作方式為 bit array，執行時間會比一般的陣列快數十倍以上。當然自己用陣列來實作 bit array 也是可行的：

```cpp
unsigned bit(int x) {
  return 1u << x;
}

void add_friend(int i, int j) {
  j--;
  f[i][j/32] |= bit(j%32);
}

bool have_common_friends(int i, int j) {
  int len = (n+31) / 32;
  for (int k=0; k<len; k++) {
    if (f[i][k] & f[j][k]) return true;
  }
  return false;
}
```

---

## F - 歡樂外送點

---

## G - 矩陣相乘

---

## H - 跑跑遊戲場

---

## I - 黑白機
